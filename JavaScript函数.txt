函数声明
函数的声明有三种方式
function fun(){}
var f = function(){},匿名函数, 当此种方法的function后有函数名时只在内部有效
var f = new Function(), 最后一个参数当做函数体
重复声明函数会覆盖前面的声明
函数没有return时, 不会返回任何值,或者返回undefined
函数声明提升(重要), 采用function命令声明函数时, 整个函数像变量声明一样被提升到代码头部
不能在非函数的代码块中声明函数(可能无效, 因为函数声明提升, 且js中无块级作用域)

函数的属性和方法
函数的name属性返回函数名
函数的length属性返回函数定义时参数的个数
toString()属性返回一个字符串, 内容为函数的源码(包含函数内部的注释)

函数的作用域
函数内部可以读取全局变量
函数内部定义的变量(局部变量)会在该作用域内覆盖同名的全局变量, 且局部变量外部无法读取
函数内部存在变量提升
函数本身的作用域就是声明时所在的作用域, 与运行时的作用域无关. 函数体内部声明的函数, 作用域绑定函数体内部

函数参数
参数若是原始类型(数值, 字符串等)的值则传递方式是传值传递, 若是复合类型(对象, 数组,函数等)的值则传递方式为传址传递
传址传递时, 若在函数内部替换掉整个参数值(而不是参数的某个属性)则不会影响原始值
同名的参数取最后出现的值
arguments对象包含了函数运行时的所有参数, 这个对象只可以在函数体内部使用
正常模式下arguments对象也可以再运行时修改, 严格模式下arguments是一个只读对象, 修改无效但不报错
arguments.length属性返回函数运行时的参数个数

闭包
函数内部可以访问外部环境的所有变量, 但是外部环境不可以访问函数内部的变量
函数内部的子函数可以读取内部变量, 因此闭包可以理解"定义在一个函数内部的函数"
闭包可以看做函数内部作用域的一个接口
闭包可以封装对象的私有属性和私有方法
function关键字出现在行首, 一律解释成语句
立即调用的函数表达式(IIFE, Immediately-Invoked Function Expression)为:
(function(){}());
(function(){})();

eval命令
eval()将字符串当做语句执行
eval在当前作用域内执行, 它没有自己的作用域
严格模式下, eval内部声明的变量不会影响到外部作用域, 但实际上也是也会影响外部作用域

